# Degirum 极简解决方案

## 问题分析
您的残留进程问题是由于 Degirum 的 `pproc_worker.py` 后处理工作进程没有正确终止导致的。从进程信息可以看到：

```
--parent_pid 2956629 --port_id 5000 --protocol tcp
```

这些工作进程监控父进程状态，但父进程退出时没有发送终止信号。

## 最简单的解决方案

### 方法1：使用 atexit 自动清理
```python
import degirum as dg
import atexit
import os

# 加载模型
zoo = dg.connect(dg.LOCAL, "path/to/model/zoo")
model = zoo.load_model("model_name")

# 程序退出时自动清理
def cleanup():
    if hasattr(model, '_release_runtime'):
        model._release_runtime()
    # 清理所有属于当前进程的工作进程
    os.system(f"pkill -f 'pproc_worker.py.*--parent_pid {os.getpid()}'")

atexit.register(cleanup)

# 使用模型
result = model("input_data")
```

### 方法2：手动清理脚本
```bash
#!/bin/bash
# cleanup_degirum.sh
# 清理当前用户的Degirum残留进程
pkill -f "pproc_worker.py.*--parent_pid $$"
echo "Degirum工作进程已清理"
```

## 硬件支持
- **默认**: 自动选择最佳可用硬件
- **指定设备**: `model = zoo.load_model("model_name", device="GPU:0")`
- **可用设备**: `zoo.supported_device_types()`

## 核心原理
1. Degirum 创建多个 `pproc_worker.py` 进程处理后处理任务
2. 工作进程通过 `--parent_pid` 监控父进程
3. 需要显式调用 `_release_runtime()` 或发送终止信号
4. 使用 `pkill` 按父进程ID清理残留进程

## 使用方法
选择任一方法即可解决残留进程问题，推荐方法1集成到代码中。